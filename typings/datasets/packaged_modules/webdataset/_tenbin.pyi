"""
This type stub file was generated by pyright.
"""

"""
Binary tensor encodings for PyTorch and NumPy.

This defines efficient binary encodings for tensors. The format is 8 byte
aligned and can be used directly for computations when transmitted, say,
via RDMA. The format is supported by WebDataset with the `.ten` filename
extension. It is also used by Tensorcom, Tensorcom RDMA, and can be used
for fast tensor storage with LMDB and in disk files (which can be memory
mapped)

Data is encoded as a series of chunks:

- magic number (int64)
- length in bytes (int64)
- bytes (multiple of 64 bytes long)

Arrays are a header chunk followed by a data chunk.
Header chunks have the following structure:

- dtype (int64)
- 8 byte array name
- ndim (int64)
- dim[0]
- dim[1]
- ...
"""
def bytelen(a): # -> int:
    """Determine the length of a in bytes."""
    ...

def bytedata(a): # -> bytearray | bytes | memoryview[Any]:
    """Return a the raw data corresponding to a."""
    ...

long_to_short = ...
long_to_short = ...
long_to_short = ...
short_to_long = ...
def check_acceptable_input_type(data, allow64): # -> None:
    """Check that the data has an acceptable type for tensor encoding.

    :param data: array
    :param allow64: allow 64 bit types
    """
    ...

def str64(s): # -> Any:
    """Convert a string to an int64."""
    ...

def unstr64(i): # -> str:
    """Convert an int64 to a string."""
    ...

def check_infos(data, infos, required_infos=...): # -> tuple[Any, Any]:
    """Verify the info strings."""
    ...

def encode_header(a, info=...): # -> <subclass of ndarray[_AnyShape, dtype[Any]] and bytearray> | <subclass of ndarray[_AnyShape, dtype[Any]] and bytes> | memoryview[int]:
    """Encode an array header as a byte array."""
    ...

def decode_header(h): # -> tuple[tuple[Any, ...], dtype[Any], str]:
    """Decode a byte array into an array header."""
    ...

def encode_list(l, infos=...): # -> list[Any]:
    """Given a list of arrays, encode them into a list of byte arrays."""
    ...

def decode_list(l, infos=...): # -> list[Any] | tuple[list[Any], list[Any]]:
    """Given a list of byte arrays, decode them into arrays."""
    ...

magic_str = ...
magic = ...
magic_bytes = ...
def roundup(n, k=...):
    """Round up to the next multiple of 64."""
    ...

def encode_chunks(l): # -> bytearray:
    """Encode a list of chunks into a single byte array, with lengths and magics.."""
    ...

def decode_chunks(buf): # -> list[Any]:
    """Decode a byte array into a list of chunks."""
    ...

def encode_buffer(l, infos=...): # -> bytearray:
    """Encode a list of arrays into a single byte array."""
    ...

def decode_buffer(buf, infos=...): # -> list[Any] | tuple[list[Any], list[Any]]:
    """Decode a byte array into a list of arrays."""
    ...

def write_chunk(stream, buf): # -> None:
    """Write a byte chunk to the stream with magics, length, and padding."""
    ...

def read_chunk(stream): # -> None:
    """Read a byte chunk from a stream with magics, length, and padding."""
    ...

def write(stream, l, infos=...): # -> None:
    """Write a list of arrays to a stream, with magics, length, and padding."""
    ...

def read(stream, n=..., infos=...): # -> list[Any] | tuple[list[Any], list[Any]]:
    """Read a list of arrays from a stream, with magics, length, and padding."""
    ...

def save(fname, *args, infos=..., nocheck=...): # -> None:
    """Save a list of arrays to a file, with magics, length, and padding."""
    ...

def load(fname, infos=..., nocheck=...): # -> list[Any] | tuple[list[Any], list[Any]]:
    """Read a list of arrays from a file, with magics, length, and padding."""
    ...

