"""
This type stub file was generated by pyright.
"""

import io
import fsspec
from pathlib import Path
from typing import Optional, TypeVar, Union
from ..download.download_config import DownloadConfig
from .track import TrackedIterableFromGenerator

"""
Utilities for working with the local dataset cache.
This file is adapted from the AllenNLP library at https://github.com/allenai/allennlp
Copyright by the AllenNLP authors.
"""
logger = ...
INCOMPLETE_SUFFIX = ...
T = TypeVar("T", str, Path)
CONNECTION_ERRORS_TO_RETRY = ...
def is_remote_url(url_or_filename: str) -> bool:
    ...

def is_local_path(url_or_filename: str) -> bool:
    ...

def is_relative_path(url_or_filename: str) -> bool:
    ...

def relative_to_absolute_path(path: T) -> T:
    """Convert relative path to absolute path."""
    ...

def url_or_path_join(base_name: str, *pathnames: str) -> str:
    ...

def url_or_path_parent(url_or_path: str) -> str:
    ...

def hash_url_to_filename(url, etag=...): # -> str:
    """
    Convert `url` into a hashed filename in a repeatable way.
    If `etag` is specified, append its hash to the url's, delimited
    by a period.
    If the url ends with .h5 (Keras HDF5 weights) adds '.h5' to the name
    so that TF 2.0 can identify it as a HDF5 file
    (see https://github.com/tensorflow/tensorflow/blob/00fad90125b18b80fe054de1055770cfb8fe4ba3/tensorflow/python/keras/engine/network.py#L1380)
    """
    ...

def cached_path(url_or_filename, download_config=..., **download_kwargs) -> str:
    """
    Given something that might be a URL (or might be a local path),
    determine which. If it's a URL, download the file and cache it, and
    return the path to the cached file. If it's already a local path,
    make sure the file exists and then return the path.

    Return:
        Local path (string)

    Raises:
        FileNotFoundError: in case of non-recoverable file
            (non-existent or no cache on disk)
        ConnectionError: in case of unreachable url
            and no cache on disk
        ValueError: if it couldn't parse the url or filename correctly
        httpx.NetworkError or requests.exceptions.ConnectionError: in case of internet connection issue
    """
    ...

def get_datasets_user_agent(user_agent: Optional[Union[str, dict]] = ...) -> str:
    ...

def get_authentication_headers_for_url(url: str, token: Optional[Union[str, bool]] = ...) -> dict:
    """Handle the HF authentication"""
    ...

def fsspec_head(url, storage_options=...): # -> Any:
    ...

def stack_multiprocessing_download_progress_bars(): # -> _patch_dict:
    ...

class TqdmCallback(fsspec.callbacks.TqdmCallback):
    def __init__(self, tqdm_kwargs=..., *args, **kwargs) -> None:
        ...
    


def fsspec_get(url, temp_file, storage_options=..., desc=..., disable_tqdm=...): # -> None:
    ...

def get_from_cache(url, cache_dir=..., force_download=..., user_agent=..., use_etag=..., token=..., storage_options=..., download_desc=..., disable_tqdm=...) -> str:
    """
    Given a URL, look for the corresponding file in the local cache.
    If it's not there, download it. Then return the path to the cached file.

    Return:
        Local path (string)

    Raises:
        FileNotFoundError: in case of non-recoverable file
            (non-existent or no cache on disk)
        ConnectionError: in case of unreachable url
            and no cache on disk
    """
    ...

def add_start_docstrings(*docstr): # -> Callable[..., Any]:
    ...

def add_end_docstrings(*docstr): # -> Callable[..., Any]:
    ...

def estimate_dataset_size(paths): # -> int:
    ...

def readline(f: io.RawIOBase): # -> bytes:
    ...

BASE_KNOWN_EXTENSIONS = ...
COMPRESSION_EXTENSION_TO_PROTOCOL = ...
SINGLE_FILE_COMPRESSION_EXTENSION_TO_PROTOCOL = ...
SINGLE_FILE_COMPRESSION_PROTOCOLS = ...
SINGLE_SLASH_AFTER_PROTOCOL_PATTERN = ...
MAGIC_NUMBER_TO_COMPRESSION_PROTOCOL = ...
MAGIC_NUMBER_TO_UNSUPPORTED_COMPRESSION_PROTOCOL = ...
MAGIC_NUMBER_MAX_LENGTH = ...
class NonStreamableDatasetError(Exception):
    ...


def xjoin(a, *p): # -> str:
    """
    This function extends os.path.join to support the "::" hop separator. It supports both paths and urls.

    A shorthand, particularly useful where you have multiple hops, is to “chain” the URLs with the special separator "::".
    This is used to access files inside a zip file over http for example.

    Let's say you have a zip file at https://host.com/archive.zip, and you want to access the file inside the zip file at /folder1/file.txt.
    Then you can just chain the url this way:

        zip://folder1/file.txt::https://host.com/archive.zip

    The xjoin function allows you to apply the join on the first path of the chain.

    Example::

        >>> xjoin("zip://folder1::https://host.com/archive.zip", "file.txt")
        zip://folder1/file.txt::https://host.com/archive.zip
    """
    ...

def xdirname(a): # -> str:
    """
    This function extends os.path.dirname to support the "::" hop separator. It supports both paths and urls.

    A shorthand, particularly useful where you have multiple hops, is to “chain” the URLs with the special separator "::".
    This is used to access files inside a zip file over http for example.

    Let's say you have a zip file at https://host.com/archive.zip, and you want to access the file inside the zip file at /folder1/file.txt.
    Then you can just chain the url this way:

        zip://folder1/file.txt::https://host.com/archive.zip

    The xdirname function allows you to apply the dirname on the first path of the chain.

    Example::

        >>> xdirname("zip://folder1/file.txt::https://host.com/archive.zip")
        zip://folder1::https://host.com/archive.zip
    """
    ...

def xexists(urlpath: str, download_config: Optional[DownloadConfig] = ...): # -> bool | Any:
    """Extend `os.path.exists` function to support both local and remote files.

    Args:
        urlpath (`str`): URL path.
        download_config : mainly use token or storage_options to support different platforms and auth types.

    Returns:
        `bool`
    """
    ...

def xbasename(a): # -> str:
    """
    This function extends os.path.basename to support the "::" hop separator. It supports both paths and urls.

    A shorthand, particularly useful where you have multiple hops, is to “chain” the URLs with the special separator "::".
    This is used to access files inside a zip file over http for example.

    Let's say you have a zip file at https://host.com/archive.zip, and you want to access the file inside the zip file at /folder1/file.txt.
    Then you can just chain the url this way:

        zip://folder1/file.txt::https://host.com/archive.zip

    The xbasename function allows you to apply the basename on the first path of the chain.

    Example::

        >>> xbasename("zip://folder1/file.txt::https://host.com/archive.zip")
        file.txt
    """
    ...

def xsplit(a): # -> tuple[str, str]:
    """
    This function extends os.path.split to support the "::" hop separator. It supports both paths and urls.

    A shorthand, particularly useful where you have multiple hops, is to “chain” the URLs with the special separator "::".
    This is used to access files inside a zip file over http for example.

    Let's say you have a zip file at https://host.com/archive.zip, and you want to access the file inside the zip file at /folder1/file.txt.
    Then you can just chain the url this way:

        zip://folder1/file.txt::https://host.com/archive.zip

    The xsplit function allows you to apply the xsplit on the first path of the chain.

    Example::

        >>> xsplit("zip://folder1/file.txt::https://host.com/archive.zip")
        ('zip://folder1::https://host.com/archive.zip', 'file.txt')
    """
    ...

def xsplitext(a): # -> tuple[str, str]:
    """
    This function extends os.path.splitext to support the "::" hop separator. It supports both paths and urls.

    A shorthand, particularly useful where you have multiple hops, is to “chain” the URLs with the special separator "::".
    This is used to access files inside a zip file over http for example.

    Let's say you have a zip file at https://host.com/archive.zip, and you want to access the file inside the zip file at /folder1/file.txt.
    Then you can just chain the url this way:

        zip://folder1/file.txt::https://host.com/archive.zip

    The xsplitext function allows you to apply the splitext on the first path of the chain.

    Example::

        >>> xsplitext("zip://folder1/file.txt::https://host.com/archive.zip")
        ('zip://folder1/file::https://host.com/archive.zip', '.txt')
    """
    ...

def xisfile(path, download_config: Optional[DownloadConfig] = ...) -> bool:
    """Extend `os.path.isfile` function to support remote files.

    Args:
        path (`str`): URL path.
        download_config : mainly use token or storage_options to support different platforms and auth types.

    Returns:
        `bool`
    """
    ...

def xgetsize(path, download_config: Optional[DownloadConfig] = ...) -> int:
    """Extend `os.path.getsize` function to support remote files.

    Args:
        path (`str`): URL path.
        download_config : mainly use token or storage_options to support different platforms and auth types.

    Returns:
        `int`: optional
    """
    ...

def xisdir(path, download_config: Optional[DownloadConfig] = ...) -> bool:
    """Extend `os.path.isdir` function to support remote files.

    Args:
        path (`str`): URL path.
        download_config : mainly use token or storage_options to support different platforms and auth types.

    Returns:
        `bool`
    """
    ...

def xrelpath(path, start=...): # -> str:
    """Extend `os.path.relpath` function to support remote files.

    Args:
        path (`str`): URL path.
        start (`str`): Start URL directory path.

    Returns:
        `str`
    """
    ...

def xopen(file: str, mode=..., *args, download_config: Optional[DownloadConfig] = ..., **kwargs): # -> IO[Any] | RawIOBase:
    """Extend `open` function to support remote files using `fsspec`.

    It also has a retry mechanism in case connection fails.
    The `args` and `kwargs` are passed to `fsspec.open`, except `token` which is used for queries to private repos on huggingface.co

    Args:
        file (`str`): Path name of the file to be opened.
        mode (`str`, *optional*, default "r"): Mode in which the file is opened.
        *args: Arguments to be passed to `fsspec.open`.
        download_config : mainly use token or storage_options to support different platforms and auth types.
        **kwargs: Keyword arguments to be passed to `fsspec.open`.

    Returns:
        file object
    """
    ...

def xlistdir(path: str, download_config: Optional[DownloadConfig] = ...) -> list[str]:
    """Extend `os.listdir` function to support remote files.

    Args:
        path (`str`): URL path.
        download_config : mainly use token or storage_options to support different platforms and auth types.

    Returns:
        `list` of `str`
    """
    ...

def xglob(urlpath, *, recursive=..., download_config: Optional[DownloadConfig] = ...): # -> list[str]:
    """Extend `glob.glob` function to support remote files.

    Args:
        urlpath (`str`): URL path with shell-style wildcard patterns.
        recursive (`bool`, default `False`): Whether to match the "**" pattern recursively to zero or more
            directories or subdirectories.
        download_config : mainly use token or storage_options to support different platforms and auth types.

    Returns:
        `list` of `str`
    """
    ...

def xwalk(urlpath, download_config: Optional[DownloadConfig] = ..., **kwargs): # -> Generator[tuple[str, list[str], list[str]] | tuple[str, Any, Any], Any, list[Any] | None]:
    """Extend `os.walk` function to support remote files.

    Args:
        urlpath (`str`): URL root path.
        download_config : mainly use token or storage_options to support different platforms and auth types.
        **kwargs: Additional keyword arguments forwarded to the underlying filesystem.


    Yields:
        `tuple`: 3-tuple (dirpath, dirnames, filenames).
    """
    ...

class xPath(type(Path())):
    """Extension of `pathlib.Path` to support both local paths and remote URLs."""
    def __str__(self) -> str:
        ...
    
    def exists(self, download_config: Optional[DownloadConfig] = ...): # -> bool | Any:
        """Extend `pathlib.Path.exists` method to support both local and remote files.

        Args:
            download_config : mainly use token or storage_options to support different platforms and auth types.

        Returns:
            `bool`
        """
        ...
    
    def glob(self, pattern, download_config: Optional[DownloadConfig] = ...): # -> Generator[Path | Self, Any, None]:
        """Glob function for argument of type :obj:`~pathlib.Path` that supports both local paths end remote URLs.

        Args:
            pattern (`str`): Pattern that resulting paths must match.
            download_config : mainly use token or storage_options to support different platforms and auth types.

        Yields:
            [`xPath`]
        """
        ...
    
    def rglob(self, pattern, **kwargs): # -> Generator[Path | Self, Any, None]:
        """Rglob function for argument of type :obj:`~pathlib.Path` that supports both local paths end remote URLs.

        Args:
            pattern (`str`): Pattern that resulting paths must match.

        Yields:
            [`xPath`]
        """
        ...
    
    @property
    def parent(self) -> xPath:
        """Name function for argument of type :obj:`~pathlib.Path` that supports both local paths end remote URLs.

        Returns:
            [`xPath`]
        """
        ...
    
    @property
    def name(self) -> str:
        """Name function for argument of type :obj:`~pathlib.Path` that supports both local paths end remote URLs.

        Returns:
            `str`
        """
        ...
    
    @property
    def stem(self) -> str:
        """Stem function for argument of type :obj:`~pathlib.Path` that supports both local paths end remote URLs.

        Returns:
            `str`
        """
        ...
    
    @property
    def suffix(self) -> str:
        """Suffix function for argument of type :obj:`~pathlib.Path` that supports both local paths end remote URLs.

        Returns:
            `str`
        """
        ...
    
    def open(self, *args, **kwargs): # -> IO[Any] | RawIOBase:
        """Extend :func:`xopen` to support argument of type :obj:`~pathlib.Path`.

        Args:
            **args: Arguments passed to :func:`fsspec.open`.
            **kwargs: Keyword arguments passed to :func:`fsspec.open`.

        Returns:
            `io.FileIO`: File-like object.
        """
        ...
    
    def joinpath(self, *p: tuple[str, ...]) -> xPath:
        """Extend :func:`xjoin` to support argument of type :obj:`~pathlib.Path`.

        Args:
            *p (`tuple` of `str`): Other path components.

        Returns:
            [`xPath`]
        """
        ...
    
    def __truediv__(self, p: str) -> xPath:
        ...
    
    def with_suffix(self, suffix): # -> Self:
        ...
    


def xgzip_open(filepath_or_buffer, *args, download_config: Optional[DownloadConfig] = ..., **kwargs):
    ...

def xnumpy_load(filepath_or_buffer, *args, download_config: Optional[DownloadConfig] = ..., **kwargs): # -> Any:
    ...

def xpandas_read_csv(filepath_or_buffer, download_config: Optional[DownloadConfig] = ..., **kwargs):
    ...

def xpandas_read_excel(filepath_or_buffer, download_config: Optional[DownloadConfig] = ..., **kwargs):
    ...

def xpyarrow_parquet_read_table(filepath_or_buffer, download_config: Optional[DownloadConfig] = ..., **kwargs):
    ...

def xsio_loadmat(filepath_or_buffer, download_config: Optional[DownloadConfig] = ..., **kwargs):
    ...

def xet_parse(source, parser=..., download_config: Optional[DownloadConfig] = ...): # -> ElementTree[Element[str]]:
    """Extend `xml.etree.ElementTree.parse` function to support remote files.

    Args:
        source: File path or file object.
        parser (`XMLParser`, *optional*, default `XMLParser`): Parser instance.
        download_config : mainly use token or storage_options to support different platforms and auth types.

    Returns:
        `xml.etree.ElementTree.Element`: Root element of the given source document.
    """
    ...

def xxml_dom_minidom_parse(filename_or_file, download_config: Optional[DownloadConfig] = ..., **kwargs): # -> Document:
    """Extend `xml.dom.minidom.parse` function to support remote files.

    Args:
        filename_or_file (`str` or file): File path or file object.
        download_config : mainly use token or storage_options to support different platforms and auth types.
        **kwargs (optional): Additional keyword arguments passed to `xml.dom.minidom.parse`.

    Returns:
        :obj:`xml.dom.minidom.Document`: Parsed document.
    """
    ...

class ArchiveIterable(TrackedIterableFromGenerator):
    """An iterable of (path, fileobj) from a TAR archive, used by `iter_archive`"""
    @classmethod
    def from_buf(cls, fileobj) -> ArchiveIterable:
        ...
    
    @classmethod
    def from_urlpath(cls, urlpath_or_buf, download_config: Optional[DownloadConfig] = ...) -> ArchiveIterable:
        ...
    


class FilesIterable(TrackedIterableFromGenerator):
    """An iterable of paths from a list of directories or files"""
    @classmethod
    def from_urlpaths(cls, urlpaths, download_config: Optional[DownloadConfig] = ...) -> FilesIterable:
        ...
    


