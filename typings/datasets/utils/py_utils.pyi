"""
This type stub file was generated by pyright.
"""

import multiprocessing.pool
import multiprocess
import multiprocess.pool
from collections.abc import Iterable
from contextlib import contextmanager
from typing import Any, Callable, Optional, TypeVar, Union

"""Some python utils function and classes."""
logger = ...
memoize = ...
def size_str(size_in_bytes): # -> str:
    """Returns a human readable size string.

    If size_in_bytes is None, then returns "Unknown size".

    For example `size_str(1.5 * datasets.units.GiB) == "1.50 GiB"`.

    Args:
        size_in_bytes: `int` or `None`, the size, in bytes, that we want to
            format as a human-readable size string.
    """
    ...

def convert_file_size_to_int(size: Union[int, str]) -> int:
    """
    Converts a size expressed as a string with digits an unit (like `"50MB"`) to an integer (in bytes).

    Args:
        size (`int` or `str`): The size to convert. Will be directly returned if an `int`.

    Example:

    ```py
    >>> convert_file_size_to_int("1MiB")
    1048576
    ```
    """
    ...

def glob_pattern_to_regex(pattern):
    ...

def string_to_dict(string: str, pattern: str) -> Optional[dict[str, str]]:
    """Un-format a string using a python f-string pattern.
    From https://stackoverflow.com/a/36838374

    Example::

        >>> p = 'hello, my name is {name} and I am a {age} year old {what}'
        >>> s = p.format(name='cody', age=18, what='quarterback')
        >>> s
        'hello, my name is cody and I am a 18 year old quarterback'
        >>> string_to_dict(s, p)
        {'age': '18', 'name': 'cody', 'what': 'quarterback'}

    Args:
        string (str): input string
        pattern (str): pattern formatted like a python f-string
            This can be a regex - so in case of un-formatting paths you should use posix paths.
            Otherwise backslashes for windows paths can cause issues.

    Returns:
        Optional[dict[str, str]]: dictionary of variable -> value, retrieved from the input using the pattern, or
        `None` if the string does not match the pattern.
    """
    ...

def asdict(obj): # -> dict[Any, Any] | tuple[Any, ...] | list[Any]:
    """Convert an object to its dictionary representation recursively.

    <Added version="2.4.0"/>
    """
    ...

@contextmanager
def temporary_assignment(obj, attr, value): # -> Generator[None, Any, None]:
    """Temporarily assign obj.attr to value."""
    ...

@contextmanager
def temp_seed(seed: int, set_pytorch=..., set_tensorflow=...): # -> Generator[None, Any, None]:
    """Temporarily set the random seed. This works for python numpy, pytorch and tensorflow."""
    ...

def unique_values(values): # -> Generator[Any, Any, None]:
    """Iterate over iterable and return only unique values in order."""
    ...

def no_op_if_value_is_null(func): # -> Callable[..., Any | None]:
    """If the value is None, return None, else call `func`."""
    ...

def first_non_null_value(iterable): # -> tuple[int, Any] | tuple[Literal[-1], None]:
    """Return the index and the value of the first non-null value in the iterable. If all values are None, return -1 as index."""
    ...

def first_non_null_non_empty_value(iterable): # -> tuple[int, Any | dict[Any, Any] | list[Any]] | tuple[Literal[-1], None]:
    """Return the index and the value of the first non-null non-empty value in the iterable. If all values are None or empty, return -1 as index."""
    ...

def zip_dict(*dicts): # -> Generator[tuple[Any, tuple[Any, ...]], Any, None]:
    """Iterate over items of dictionaries grouped by their keys."""
    ...

class NonMutableDict(dict):
    """Dict where keys can only be added but not modified.

    Will raise an error if the user try to overwrite one key. The error message
    can be customized during construction. It will be formatted using {key} for
    the overwritten key.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __setitem__(self, key, value): # -> None:
        ...
    
    def update(self, other): # -> None:
        ...
    


class classproperty(property):
    """Descriptor to be used as decorator for @classmethods."""
    def __get__(self, obj, objtype=...): # -> Any:
        ...
    


def map_nested(function: Callable[[Any], Any], data_struct: Any, dict_only: bool = ..., map_list: bool = ..., map_tuple: bool = ..., map_numpy: bool = ..., num_proc: Optional[int] = ..., parallel_min_length: int = ..., batched: bool = ..., batch_size: Optional[int] = ..., types: Optional[tuple] = ..., disable_tqdm: bool = ..., desc: Optional[str] = ...) -> Any:
    """Apply a function recursively to each element of a nested data struct.

    Use multiprocessing if num_proc > 1 and the length of data_struct is greater than or equal to
    `parallel_min_length`.

    <Changed version="2.5.0">

    Before version 2.5.0, multiprocessing was not used if `num_proc` was greater than or equal to ``len(iterable)``.

    Now, if `num_proc` is greater than or equal to ``len(iterable)``, `num_proc` is set to ``len(iterable)`` and
    multiprocessing is used.

    </Changed>

    Args:
        function (`Callable`): Function to be applied to `data_struct`.
        data_struct (`Any`): Data structure to apply `function` to.
        dict_only (`bool`, default `False`): Whether only apply `function` recursively to `dict` values in
            `data_struct`.
        map_list (`bool`, default `True`): Whether also apply `function` recursively to `list` elements (besides `dict`
            values).
        map_tuple (`bool`, default `False`): Whether also apply `function` recursively to `tuple` elements (besides
            `dict` values).
        map_numpy (`bool, default `False`): Whether also apply `function` recursively to `numpy.array` elements (besides
            `dict` values).
        num_proc (`int`, *optional*): Number of processes.
            The level in the data struct used for multiprocessing is the first level that has smaller sub-structs,
            starting from the root.
        parallel_min_length (`int`, default `2`): Minimum length of `data_struct` required for parallel
            processing.
            <Added version="2.5.0"/>
        batched (`bool`, defaults to `False`):
            Provide batch of items to `function`.
            <Added version="2.19.0"/>
        batch_size (`int`, *optional*, defaults to `1000`):
            Number of items per batch provided to `function` if `batched=True`.
            If `batch_size <= 0` or `batch_size == None`, provide the full iterable as a single batch to `function`.
            <Added version="2.19.0"/>
        types (`tuple`, *optional*): Additional types (besides `dict` values) to apply `function` recursively to their
            elements.
        disable_tqdm (`bool`, default `True`): Whether to disable the tqdm progressbar.
        desc (`str`, *optional*): Prefix for the tqdm progressbar.

    Returns:
        `Any`
    """
    ...

class NestedDataStructure:
    def __init__(self, data=...) -> None:
        ...
    
    def flatten(self, data=...): # -> list[Any]:
        ...
    


def has_sufficient_disk_space(needed_bytes, directory=...): # -> Literal[True]:
    ...

def copyfunc(func): # -> FunctionType:
    ...

Y = TypeVar("Y")
def iflatmap_unordered(pool: Union[multiprocessing.pool.Pool, multiprocess.pool.Pool], func: Callable[..., Iterable[Y]], *, kwargs_iterable: Iterable[dict]) -> Iterable[Y]:
    ...

T = TypeVar("T")
def iter_batched(iterable: Iterable[T], n: int) -> Iterable[list[T]]:
    ...

